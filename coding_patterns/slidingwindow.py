# AUTOGENERATED! DO NOT EDIT! File to edit: 00_slidingwindow.ipynb (unless otherwise specified).

__all__ = ['naive_solution_to_max_sum_subarray_of_size_k', 'optimal_solution_to_max_sum_subarray_of_size_k',
           'smallest_subarray_sum', 'longest_substring_with_k_distinct', 'fruits_into_basket',
           'longest_substring_with_distinct_char', 'length_of_longest_substring', 'length_of_longest_substring',
           'find_permutation', 'find_string_anagrams', 'find_substring', 'find_word_concatenation']

# Cell

def naive_solution_to_max_sum_subarray_of_size_k(arr, k):
    """
    Given an array of positive numbers and a positive
    number 'k', find the maximum sum of any contiguous
    subarray of size 'k'.
    """
    max_sum = 0
    for i in range(len(arr)-k+1):
        _sum = 0
        for j in range(i, i+k):
            _sum += arr[j]
        max_sum = max(_sum, max_sum)
    return max_sum

# Cell

def optimal_solution_to_max_sum_subarray_of_size_k(arr, k):
    """
    Given an array of positive numbers and a positive
    number 'k', find the maximum sum of any contiguous
    subarray of size 'k'.
    """
    max_sum = 0
    window_start = 0
    window_sum = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum

# Cell

def smallest_subarray_sum(arr, s):
    """
    Given an array of positive integers and a number 'S', find the
    length of the smallest contiguous subarray whose sum is greater
    than of equal to 'S'. Return 0 if no such subarray exists.
    """
    window_start = 0
    window_sum = 0
    min_length = float('inf')
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= s:
            min_length = min(min_length, window_end-window_start+1)
            window_sum -= arr[window_start]
            window_start += 1
    if min_length == float('inf'):
        return 0
    return min_length

# Cell

def longest_substring_with_k_distinct(s, k):
    """
    Given a string find the length of the longest substring in it with no more than K distinct characters.
    """
    char_freq = {}
    window_start = 0
    max_length = float('-inf')
    for window_end in range(len(s)):
        char = s[window_end]
        char_freq[char] = char_freq.get(char, 0) + 1

        while len(char_freq) > k :
            char = s[window_start]
            char_freq[char] -= 1
            if char_freq[char] == 0:
                del char_freq[char]
            window_start += 1

        max_length = max(max_length, window_end-window_start+1)
    return max_length

# Cell

def fruits_into_basket(fruits):
    """
    Variation of longest substring with k distinct characters.
    """
    char_freq = {}
    window_start = 0
    max_length = 0
    for window_end in range(len(fruits)):
        char = fruits[window_end]
        char_freq[char] = char_freq.get(char, 0) + 1
        while len(char_freq) > 2:
            char = fruits[window_start]
            char_freq[char] -= 1
            if char_freq[char] == 0:
                del char_freq[char]
            window_start += 1
        max_length = max(max_length, window_end-window_start+1)
    return max_length

# Cell

def longest_substring_with_distinct_char(s):
    """
    Given a string, find the length of the longest substring,
    which has all distinct characters.
    """
    char_freq = {}
    window_start = 0
    max_length = float('-inf')
    for window_end in range(len(s)):
        char = s[window_end]
        if char in char_freq:
            window_start = max(window_start, char_freq[char]+1)
        char_freq[char] = window_end
        max_length = max(max_length, window_end-window_start+1)
    return max_length

# Cell
def length_of_longest_substring(s, k):
    """
    Given a string with lowercase letters only, if you are allowed to replace no more
    than k letters with any letter, find the length of the longest substring having
    the same letters after replacement.
    """
    char_freq = {}
    window_start = 0
    max_repeat_letter_count = 0
    max_length = float('-inf')
    for window_end in range(len(s)):
        char = s[window_end]
        char_freq[char] = char_freq.get(char, 0) + 1
        max_repeat_letter_count = max(max_repeat_letter_count, char_freq[char])

        if window_end-window_start+1-max_repeat_letter_count > k:
            char = s[window_start]
            char_freq[char] -= 1
            window_start += 1

        max_length = max(max_length, window_end-window_start+1)
    return max_length

# Cell

def length_of_longest_substring(arr, k):
    """
    Given an array containing 0s and 1s, if you are allowed to replace no
    more than ‘k’ 0s with 1s, find the length of the longest contiguous subarray
    having all 1s.
    """
    window_start = 0
    max_ones = 0
    max_length = float('-inf')
    for window_end in range(len(arr)):
        if arr[window_end] == 1:
            max_ones += 1
        if window_end - window_start + 1 - max_ones > k:
            if arr[window_start] == 1:
                max_ones -= 1
            window_start += 1
        max_length = max(max_length, window_end-window_start+1)
    return max_length

# Cell

def find_permutation(s, pattern):
    char_freq = {}
    for char in pattern:
        char_freq[char] = char_freq.get(char, 0) + 1

    window_start = 0
    matched = 0
    for window_end in range(len(s)):
        char = s[window_end]
        if char in char_freq:
            char_freq[char] -= 1
            if char_freq[char] == 0:
                matched += 1
        if matched == len(char_freq):
            return True

        if window_end >= len(pattern) - 1:
            char = s[window_start]
            window_start += 1
            if char in char_freq:
                if char_freq[char] == 0:
                    matched -= 1
                char_freq[char] += 1
    return False

# Cell

def find_string_anagrams(s, pattern):
    char_freq = {}
    for char in pattern:
        char_freq[char] = char_freq.get(char, 0) + 1

    window_start = 0
    matched = 0
    result_indices = []
    for window_end in range(len(s)):
        char = s[window_end]
        if char in char_freq:
            char_freq[char] -= 1
            if char_freq[char] == 0:
                matched += 1

        if matched == len(char_freq):
            result_indices.append(window_start)

        if window_end >= len(pattern) - 1:
            char = s[window_start]
            window_start += 1
            if char in char_freq:
                if char_freq[char] == 0:
                    matched -= 1
                char_freq[char] += 1
    return result_indices

# Cell

def find_substring(s, pattern):
    char_freq = {}
    for char in pattern:
        char_freq[char] = char_freq.get(char, 0) + 1

    window_start = 0
    substr_start = 0
    min_length = len(s) + 1
    matched = 0
    for window_end in range(len(s)):
        char = s[window_end]
        if char in char_freq:
            char_freq[char] -= 1
            if char_freq[char] >= 0:
                matched += 1

        while matched == len(pattern):
            if min_length > window_end - window_start + 1:
                min_length = min(min_length, window_end-window_start+1)
                substr_start = window_start

            char = s[window_start]
            window_start += 1
            if char in char_freq:
                if char_freq[char] == 0:
                    matched -= 1
                char_freq[char] += 1
    if min_length > len(s):
        return ""
    return s[substr_start:substr_start+min_length]

# Cell

def find_word_concatenation(s, words):
    result_indices = []

    if len(words) == 0 or len(words[0]) == 0:
        return []

    word_freq = {}
    for word in words:
        word_freq[word] = word_freq.get(word, 0) + 1

    words_count = len(words)
    word_length = len(words[0])

    for i in range((len(s)-words_count*word_length)+1):
        words_seen = {}
        for j in range(0, word_length):
            next_word_idx = i + j * word_length
            word = s[next_word_idx:next_word_idx+word_length]
            if word not in word_freq:
                break
            words_seen[word] = words_seen.get(word, 0) + 1
            if words_seen[word] > word_freq.get(word, 0):
                break
            if j + 1 == words_count:
                result_indices.append(i)
    return result_indices